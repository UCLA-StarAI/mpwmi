from fractions import Fraction
from functools import reduce
from typing import List, Dict

from pympwmi import logger
from pysmi.utils import categorize_bounds, get_real_variables, initiate_bound, \
    is_literal, line_sweep, get_coefficients, get_constants
from pysmt.fnode import FNode
from pysmt.operators import POW
from pysmt.shortcuts import And, LE, LT, Or, REAL, Real, simplify, substitute, \
    Plus, Times
from sympy import Add, Mul, Pow, Poly
from sympy import Symbol as symSymbol
from sympy.core.symbol import Symbol as symvar
from sympy.polys.domains.mpelements import RealElement as symReal

# default value for the random seed if not provided by the user
RAND_SEED = 1337

# default SMT solver to be used in pySMT
SMT_SOLVER = "msat"
# SMT_SOLVER = "z3"
# SMT_SOLVER = "cvc4"

# TODO: documentation is incomplete/ambiguous. method might need refactoring too


def clause_to_intervals(clause: FNode,
                        sender_symbol: FNode,
                        test_point: float):
    """
    turn clause into a list of  intervals,
    where there are at most two intervals
    :param clause: OR FNode or a single atom
    :param sender_symbol:
    :param test_point: an initiation value for recipient variable
    :return: list of tuples of form [lower, upper]
    """
    upper_bounds, lower_bounds, recipient_atoms = categorize_bounds(
        clause, sender_symbol
    )
    if recipient_atoms:
        parent_symbol = list(get_real_variables(recipient_atoms[0]))
        for atom in recipient_atoms:
            bound = simplify(substitute(
                atom, {parent_symbol[0]: Real(test_point)})
            )
            if bound.is_true():
                return []

    num_uppers = [initiate_bound(upper, test_point) for upper in upper_bounds]
    num_lowers = [initiate_bound(lower, test_point) for lower in lower_bounds]
    if not num_uppers and not num_lowers:
        return []
    if not num_uppers:
        return [[min(num_lowers), float('inf')]]
    if not num_lowers:
        return [[float('-inf'), max(num_uppers)]]

    max_upper, min_lower = max(num_uppers), min(num_lowers)
    if max_upper < min_lower:
        return [[float('-inf'), max_upper], [min_lower, float('inf')]]
    else:
        return []


# TODO: documentation is incomplete/ambiguous. method might need refactoring too
def construct_bound_dict(sender_constraints: list,
                         sender_symbol: FNode,
                         test_point: float,
                         formula: FNode):
    """
    read from constrains and formula Delta_x,y to obtain integration bound
    dictionary from numeric ones to symbolic ones
    :param sender_constraints: list of tuples of form [l, u, p]
    with l, u float bounds and p a polynomial
    :param sender_symbol:
    :param test_point:
    :param formula: formula: edge formula, Delta_x,y
    :return: two dictionary for upper bounds and lower bounds respectively
    """
    upper_bounds, lower_bounds, _ = categorize_bounds(formula, sender_symbol)
    num_upper_bounds, num_lower_bounds = dict(), dict()
    for upper in upper_bounds:
        num_upper_bounds[initiate_bound(upper, test_point)] = upper
    for lower in lower_bounds:
        num_lower_bounds[initiate_bound(lower, test_point)] = lower
    for lower, upper, _ in sender_constraints:
        num_upper_bounds[upper] = Real(upper)
        num_lower_bounds[lower] = Real(lower)
    return num_upper_bounds, num_lower_bounds


NOT_CSTR = 0  # not constraints
LEFT_END = 1
RIGHT_END = 0


# TODO: documentation is incomplete/ambiguous. method might need refactoring too
def find_symbolic_bounds(sender_constraints: list,
                         sender_symbol: FNode,
                         test_point: float,
                         formula: FNode):
    """
    find the symbolic integration bounds and also index of integrand
    :param sender_constraints: list of tuples of form [l, u, p]
    with l, u float bounds and p a polynomial
    :param sender_symbol: FNode of variable
    :param test_point: mid point of an interval of recipient
    :param formula: edge formula, Delta_x,y
    :return: list of tuples of form [symbolic bounds, index]
    """
    interval_list = formula_to_interval_set(formula, sender_symbol, test_point)
    list_num = len(interval_list)
    points = []
    for i in range(list_num):
        for interval in interval_list[i]:
            start, end = interval
            points.append([start, NOT_CSTR, i, LEFT_END])
            points.append([end, NOT_CSTR, i, RIGHT_END])

    for idx, interval in enumerate(sender_constraints):
        start, end, _ = interval
        points.append([start, idx, list_num, LEFT_END])
        points.append([end, idx, list_num, RIGHT_END])
    points.sort(key=lambda p: (p[0], p[3]), reverse=False)
    intersection = line_sweep(points, list_num + 1)
    num_upper_bounds, num_lower_bounds = construct_bound_dict(
        sender_constraints, sender_symbol, test_point, formula
    )

    symbolic_bounds = []
    for start, end, idx in intersection:
        symbolic_bounds.append(
            [num_lower_bounds[start], num_upper_bounds[end], idx]
        )
    return symbolic_bounds


def literal_to_bounds(f: FNode):
    """
    obtain bounds on variable x from inequality atom
    :param literal: ax + by + c < dx + ey + f
    :param x: variable
    :return: symbolic bound for x, is_lower, k_inclduded

    for example, given literal 3x + 2y + 4 < x + y + 1,
    first move all terms to left hand side: 2x + y + 3 < 0,
    then it returns [-1/2 y - 3/2, False]
    since the literal is equivalent to x < -1/2 y - 3/2
    """
    assert (is_literal(f))
    assert f.is_le() or f.is_lt()
    variables = list(get_real_variables(f))

    k_included = f.is_le()
    f = simplify(f)
    lhs, rhs = f.arg(0), f.arg(1)

    lhs_coef, lhs_const = get_coefficients(lhs), get_constants(lhs)
    rhs_coef, rhs_const = get_coefficients(rhs), get_constants(rhs)
    # move all terms to lhs
    const = simplify(lhs_const - rhs_const)
    coef = dict()
    for v in variables:
        coef[v] = simplify(lhs_coef[v] - rhs_coef[v])

    bounds = dict()
    for v in variables:
        if float(coef[v].constant_value()) == 0:
            continue

        bound_terms = [simplify(const * Real(-1) / coef[v])]
        for w in variables:
            if w == v or float(coef[w].constant_value()) == 0:
                continue
            new_w_coef = simplify(coef[w] * Real(-1) / coef[v])
            bound_terms.append(Times(new_w_coef, w))
        bound = Plus(bound_terms)
        is_lower = coef[v].constant_value() < 0
        bounds[v] = bound, is_lower, k_included

    return bounds


def flip_ra_atom(atom):
    """
    Flips an LRA/NRA atom, i.e.:
    - if 'atom' is (x < y), returns (y <= x)
    - if 'atom' is (x <= y), returns (y < x)
    otherwise, raises ValueError.

    Parameters
    ----------
    atom : pysmt.FNode instance
        The LRA/NRA atom
    """
    if atom.is_le():
        return LT(atom.args()[1], atom.args()[0])
    elif atom.is_lt():
        return LE(atom.args()[1], atom.args()[0])
    else:
        raise ValueError("Negated literals outside LE and LT are not supported")


def flip_negated_literals_cnf(f):
    """
    Removes the negated LRA/NRA literals in 'f' by pushing the negation into the
    relation, while leaving the negated boolean atoms unaltered.
    Returns a pysmt.FNode instance that is equivalent to 'f'.
    Raises ValueError if the 'f' is not in CNF.

    Parameters
    ----------
    f : pysmt.FNode instance
    """

    if is_literal(f):
        if is_ra_literal(f) and f.is_not():
            return flip_ra_atom(f.args()[0])

        else:
            return f

    elif f.is_or():
        return Or([flip_negated_literals_cnf(l) for l in f.args()])

    elif f.is_and():
        return And([flip_negated_literals_cnf(c) for c in f.args()])

    else:
        raise ValueError("Formula not in CNF {}".format(f))


# TODO: documentation is incomplete/ambiguous. method might need refactoring too
def formula_to_interval_set(formula: FNode,
                            sender_symbol: FNode,
                            test_point: float):
    clauses = set()
    if formula.is_or() or is_literal(formula):
        clauses.add(formula)
    else:  # formula of CNF form
        for clause in formula.args():
            assert is_literal(clause) or clause.is_or()
            clauses.add(clause)

    interval_list = []
    for clause in clauses:
        intervals = clause_to_intervals(clause, sender_symbol, test_point)
        if intervals:
            interval_list.append(intervals)
    return interval_list


def is_ra_literal(f):
    """
    Tests whether 'f' is an LRA/NRA literal.

    Parameters
    ----------
    f : pysmt.FNode instance
        Input formula
    """
    return is_literal(f) and all(v.symbol_type() == REAL
                                 for v in f.get_free_variables())


def is_sympy_expr(expr):
    """
    Tests whether 'expr' is a sympy expression.

    Parameters
    ----------
    expr : any object
        Input formula
    """
    return 'sympy' in type(expr).__module__


def parse_univariate_literal(f):
    """
    Not complete. Given a univariate literal f, returns:
    - the variable x
    - the simplified endpoint k
    - a flag that is True iff f is a lower bound to x
    - a flag that is True iff the endpoint k is included

    WARNING: again, not complete, i.e. it doesn't work for arbitrary
    univariate literals.
    """
    assert (is_literal(f))
    assert (len(f.get_free_variables()) == 1)
    # TODO: is this needed, given that we flip every xRA literal as a
    # preprocessing step?
    if f.is_not():
        f = flip_ra_atom(f.args()[0])

    f = simplify(f)
    x = list(f.get_free_variables())[0]
    k_included = f.is_le()

    l, r = f.args()
    if l.is_real_constant():
        is_lower = True
        k = l.constant_value()
        ax = r

    elif r.is_real_constant():
        is_lower = False
        k = r.constant_value()
        ax = l

    else:
        raise ValueError(f"Can't parse the univariate literal {f.serialize()}")

    if ax.is_times():
        assert (len(ax.args()) == 2)
        assert (ax.args()[0].is_symbol())
        assert (ax.args()[1].is_real_constant())
        k = k / ax.args()[1].constant_value()

    elif ax.is_plus():
        assert (len(ax.args()) == 2)
        assert (ax.args()[0].is_symbol())
        assert (ax.args()[1].is_real_constant())
        k = k - ax.args()[1].constant_value()

    elif not ax.is_symbol():
        raise ValueError(f"Can't parse the univariate literal {f.serialize()}")

    return x, k, is_lower, k_included


def to_sympy(expr):
    """
    Tries to convert an object into something that is amenable to symbolic
    integration with sympy.

    Parameters
    ----------
    expr : object
        The algebraic expression to convert
    """

    try:
        return Fraction(str(expr))
    except ValueError:
        pass
    if type(expr) == FNode:
        return pysmt_to_sympy(expr)
    else:
        # TODO: here we might want to add some sanity checks on the input
        # instead of just returning it unaltered.
        return expr


def pysmt_to_sympy(expr):
    """
    Convert a pysmt expression into the sympy format.

    Parameters
    ----------
    expr : pysmt.FNode
        The pysmt expression
    """
    if expr.is_constant():
        return Fraction(expr.constant_value())
    if expr.is_symbol():
        return symSymbol(expr.symbol_name())
    else:
        subexpr = list(map(lambda x: pysmt_to_sympy(x), expr.args()))
        if expr.node_type() == POW:
            return Pow(subexpr[0], subexpr[1])
        elif expr.is_times():
            return Mul(*subexpr)
        elif expr.is_plus():
            return Add(*subexpr)


def weight_to_lit_potentials(expr):
    """Converts a pysmt.FNode instance into the MPWMI data structure for
    weights if the input encodes potentials associated to literals, i.e.:

    Times(Ite(lit_1, w_1, Real(1)), ..., Ite(lit_n, w_n, Real(1)))

    Or the constant Real(1).

    Raises ValueError otherwise.


    Parameters
    ---------- 
    expr : pysmt.FNode 
        The pysmt expression
    """
    def ite_to_potential(expr):

        if expr.is_ite():
            cond, wpos, wneg = expr.args()
            if (is_literal(cond) and wneg.is_real_constant() and wneg.constant_value() == 1):
                return cond, wpos

        raise ValueError(
            "The expression is not Times(Ite(lit_1, w_1, Real(1)), ..., Ite(lit_n, w_n, Real(1)))")

    if expr.is_times():
        wls = [ite_to_potential(a) for a in expr.args()]
    elif expr.is_real_constant() and expr.constant_value() == 1:
        return {}
    else:
        wls = [ite_to_potential(expr)]

    potentials = {}
    for lit, w in wls:
        variables = list(lit.get_free_variables())
        v = tuple(sorted(map(lambda x: x.symbol_name(), variables)))
        assert(len(v) in [1, 2]), "Not implemented for ternary atoms"

        if v not in potentials:
            potentials[v] = []

        symv = tuple([symvar(x) for x in v])
        symw = Poly(to_sympy(w), symv, domain="RR")
        potentials[v].append((lit, symw))

    return potentials


def ordered_variables(expr):
    """Given an input sympy 'expr', returns an ordered list of its
    variables.

    Parameters
    ---------- 
    expr : sympy.something
        The sympy expression

    """
    if expr.is_symbol:
        return [expr]
    elif len(expr.args) == 0:
        return []
    else:
        res = []
        for a in expr.args:
            res.extend(ordered_variables(a))

        return res
        # return list(reduce(lambda x, y: x.extend(y),
        #                    [ordered_variables(a) for a in expr.args]))


def dict_to_tuple(d):
    if d == {}:
        return [(((), symReal(0)))]

    t = list(d.keys())
    assert len(t[0]) < 3, f"t[0] = {t[0]} should not happen"
    if len(t[0]) == 1:
        return [tuple(sorted(
            (tuple((k, v)) for k, v in d.items()), key=lambda p: p[0][0]
        ))]
    elif len(t[0]) == 2:
        return [tuple(sorted(
            (tuple((k, v)) for k, v in d.items()),
            key=lambda p: (p[0][0], p[0][1])
        )), tuple(sorted(
            (tuple(((k[1], k[0]), v)) for k, v in d.items()),
            key=lambda p: (p[0][0], p[0][1])
        ))]


def cache_key2(p):
    return dict_to_tuple(p.as_dict(native=True))
